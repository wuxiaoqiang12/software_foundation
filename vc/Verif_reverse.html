<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Verif_reverse: Linked lists in Verifiable C</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/vc.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 5beta: Verifiable C</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>Table of Contents</li></a>
   <a href='coqindex.html'><li class='section_name'>Index</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">Verif_reverse<span class="subtitle">Linked lists in Verifiable C</span></h1>


<div class="doc">

<div class="paragraph"> </div>

<a name="lab31"></a><h2 class="section">Here is a little C program, <span class="inlinecode"><span class="id" type="var">reverse.c</span></span></h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<pre>
#include &lt;stddef.h&gt;

struct list {unsigned head; struct list *tail;};

struct list *reverse (struct list *p) {
  struct list *w, *t, *v;
  w = NULL;
  v = p;
  while (v) {
    t = v-&gt;tail;
    v-&gt;tail = w;
    w = v;
    v = t;
  }
  return w;
}
</pre>
 
<div class="paragraph"> </div>

 SEE ALSO VC.pdf Chapter 46 (<i>Proof of the reverse program</i>) 
<div class="paragraph"> </div>

 As usual, we import the Verifiable C system <span class="inlinecode"><span class="id" type="var">VST.floyd.proofauto</span></span>,
  then the program to be verified, in this case <span class="inlinecode"><span class="id" type="var">reverse</span></span>.  Then we give
  the standard boilerplate definitions of <span class="inlinecode"><span class="id" type="var">CompSpecs</span></span> and <span class="inlinecode"><span class="id" type="var">Vprog</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="library">VST.floyd.proofauto</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="library">reverse</span>.<br/>
<span class="id" type="keyword">Instance</span> <a name="CompSpecs"><span class="id" type="instance">CompSpecs</span></a> : <span class="id" type="class">compspecs</span>. <span class="id" type="var">make_compspecs</span> <span class="id" type="definition">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="Vprog"><span class="id" type="definition">Vprog</span></a> : <span class="id" type="definition">varspecs</span>. <span class="id" type="var">mk_varspecs</span> <span class="id" type="definition">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
</div>

<div class="doc">
<a name="lab32"></a><h2 class="section">Inductive definition of linked lists</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">Tstruct</span></span> <span class="inlinecode"><span class="id" type="var">_list</span></span> <span class="inlinecode"><span class="id" type="var">noattr</span></span> is the AST (abstract syntax tree) description
 of the C-language type <span class="inlinecode"><span class="id" type="keyword">struct</span></span> <span class="inlinecode"><span class="id" type="var">list</span></span>.  We will be using this a lot,
 so we make an abbreviation for it, t_list: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="t_list"><span class="id" type="definition">t_list</span></a> := <span class="id" type="constructor">Tstruct</span> <span class="id" type="definition">_list</span> <span class="id" type="definition">noattr</span>.<br/>
</div>

<div class="doc">
We will define a separation-logic predicate, <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>,
 to describe the concept that the address <span class="inlinecode"><span class="id" type="var">p</span></span> in 
memory is a linked list that represents
 the mathematical sequence <span class="inlinecode"><span class="id" type="var">sigma</span></span>.  Here, <span class="inlinecode"><span class="id" type="var">sigma</span></span> is a list of <span class="inlinecode"><span class="id" type="var">val</span></span>,
 which is C's "value" type: integers, pointers, floats, etc. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="listrep"><span class="id" type="definition">listrep</span></a> (<span class="id" type="var">sigma</span>: <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">val</span>) (<span class="id" type="var">p</span>: <span class="id" type="inductive">val</span>) : <span class="id" type="definition">mpred</span> :=<br/>
&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;| <span class="id" type="var">h</span>::<span class="id" type="var">hs</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">EX</span> <span class="id" type="var">y</span>:<span class="id" type="inductive">val</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">data_at</span> <span class="id" type="definition">Tsh</span> <a class="idref" href="Verif_reverse.html#t_list"><span class="id" type="definition">t_list</span></a> (<span class="id" type="var">h</span>,<a class="idref" href="Verif_reverse.html#y"><span class="id" type="variable">y</span></a>) <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>  *  <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <span class="id" type="var">hs</span> <a class="idref" href="Verif_reverse.html#y"><span class="id" type="variable">y</span></a><br/>
&nbsp;| <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil"><span class="id" type="constructor">nil</span></a> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;!! (<a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> = <span class="id" type="definition">nullval</span>) &amp;&amp; <span class="id" type="method">emp</span><br/>
&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
This says, if <span class="inlinecode"><span class="id" type="var">sigma</span></span> has head <span class="inlinecode"><span class="id" type="var">h</span></span> and tail <span class="inlinecode"><span class="id" type="var">hs</span></span>, then
  there is a cons cell at address <span class="inlinecode"><span class="id" type="var">p</span></span> with components <span class="inlinecode">(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)</span>.
  This cons cell is described by <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span>.
  Separate from that, at address <span class="inlinecode"><span class="id" type="var">y</span></span>, there is the representation
  of the rest of the list, <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">hs</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span>.  The memory footprint
  for <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>::<span class="id" type="var">hs</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span> contains the first cons cell at address <span class="inlinecode"><span class="id" type="var">p</span></span>,
  and the rest of the cons cells in the list starting at address <span class="inlinecode"><span class="id" type="var">y</span></span>.

<div class="paragraph"> </div>

  But if <span class="inlinecode"><span class="id" type="var">sigma</span></span> is <span class="inlinecode"><span class="id" type="var">nil</span></span>, then <span class="inlinecode"><span class="id" type="var">p</span></span> is the null pointer,
  and the memory footprint is empty (<span class="inlinecode"><span class="id" type="var">emp</span></span>).  The fact <span class="inlinecode"><span class="id" type="var">p</span>=<span class="id" type="var">nullval</span></span> is a pure proposition (Coq <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>); we inject this
  into the assertion language (Coq <span class="inlinecode"><span class="id" type="var">mpred</span></span>) using the <span class="inlinecode">!!</span> operator.

<div class="paragraph"> </div>

  Because <span class="inlinecode">!!<span class="id" type="var">P</span></span> (for a proposition <span class="inlinecode"><span class="id" type="var">P</span></span>) does not specify any footprint
  (whether empty or otherwise), we do not use the separating conjunction
  <span class="inlinecode">*</span> to combine it with <span class="inlinecode"><span class="id" type="var">emp</span></span>;  <span class="inlinecode">!!<span class="id" type="var">P</span></span> has no specification to separate
  from.  Instead, we use the ordinary conjunction <span class="inlinecode">&amp;&amp;</span>.

<div class="paragraph"> </div>

 Now, we want to prevent the <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> tactic from
 automatically unfolding <span class="inlinecode"><span class="id" type="var">listrep</span></span>.  This is a
 design choice that you might make differently,
 in which case, leave out the <span class="inlinecode"><span class="id" type="var">Arguments</span></span> command. 
</div>
<div class="code code-tight">

<span class="id" type="var">Arguments</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span> : <span class="id" type="tactic">simpl</span> <span class="id" type="var">never</span>.<br/>
</div>

<div class="doc">
<a name="lab33"></a><h2 class="section">Hint databases for spatial operators</h2>

<div class="paragraph"> </div>

 Whenever you define a new spatial operator&mdash;a definition
  of type <span class="inlinecode"><span class="id" type="var">mpred</span></span> such as <span class="inlinecode"><span class="id" type="var">listrep</span></span>&mdash;it's useful to populate
  two hint  databases.
  The <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> hint is a lemma that extracts
  pure propositional facts from a spatial fact.
  The <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> hint is a lemma that extracts a
  valid-pointer fact from a spatial lemma.
 
<div class="paragraph"> </div>

 Consider this proof goal: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="data_at_isptr_example1"><span class="id" type="lemma">data_at_isptr_example1</span></a>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">h</span> <span class="id" type="var">y</span> <span class="id" type="var">p</span> : <span class="id" type="inductive">val</span>) ,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="definition">data_at</span> <span class="id" type="definition">Tsh</span> <a class="idref" href="Verif_reverse.html#t_list"><span class="id" type="definition">t_list</span></a> (<a class="idref" href="Verif_reverse.html#h"><span class="id" type="variable">h</span></a>,<a class="idref" href="Verif_reverse.html#y"><span class="id" type="variable">y</span></a>) <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |-- !! <span class="id" type="definition">isptr</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
This means <span class="inlinecode"><span class="id" type="var">p</span></span> is a non-null pointer, not NULL or Vundef or a floating-point number: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="definition">isptr</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;fun&nbsp;v&nbsp;:&nbsp;val&nbsp;=&gt;&nbsp;match&nbsp;v&nbsp;with&nbsp;Vptr&nbsp;_&nbsp;_&nbsp;=&gt;&nbsp;True&nbsp;|&nbsp;_&nbsp;=&gt;&nbsp;False&nbsp;end&nbsp;*)</span><br/>
</div>

<div class="doc">
The goal solves automatically, using <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> 
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="data_at_isptr_example2"><span class="id" type="lemma">data_at_isptr_example2</span></a>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">h</span> <span class="id" type="var">y</span> <span class="id" type="var">p</span> : <span class="id" type="inductive">val</span>) ,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="definition">data_at</span> <span class="id" type="definition">Tsh</span> <a class="idref" href="Verif_reverse.html#t_list"><span class="id" type="definition">t_list</span></a> (<a class="idref" href="Verif_reverse.html#h"><span class="id" type="variable">h</span></a>,<a class="idref" href="Verif_reverse.html#y"><span class="id" type="variable">y</span></a>) <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |-- !! <span class="id" type="definition">isptr</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
Let's look more closely at how <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> solves this goal.  
     First, it finds all the pure propositions <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> that it can deduce from  the
     <span class="inlinecode"><span class="id" type="var">mpred</span></span> conjuncts on the left-hand side, and puts them above the line. 
</div>
<div class="code code-tight">
<span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> tactic uses a Hint database (also called <span class="inlinecode"><span class="id" type="var">saturate_local</span></span>)
   to look up the individual conjuncts on the left-hand side (this particular entailment
   has just one conjunct). 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">HintDb</span> <span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
In this case, the new propositions above the line are labeled <span class="inlinecode"><span class="id" type="var">H</span></span> and <span class="inlinecode"><span class="id" type="var">H<sub>0</sub></span></span>.  Next, if the proof goal has just a proposition <span class="inlinecode">!!<span class="id" type="var">P</span></span> on the right,
    <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> throws away the left-hand-side and tries to prove <span class="inlinecode"><span class="id" type="var">P</span></span>.
    (This is rather aggressive, and can sometimes lose information, that is,
     sometimes <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> will turn a provable goal into an unprovable goal.)

</div>
<div class="code code-tight">
<span class="id" type="tactic">apply</span> <span class="id" type="method">prop_right</span>.<br/>
</div>

<div class="doc">
It happens that <span class="inlinecode"><span class="id" type="var">field_compatible</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> implies <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="lemma">field_compatible_isptr</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;:&nbsp;forall&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(path&nbsp;:&nbsp;list&nbsp;gfield)&nbsp;(p&nbsp;:&nbsp;val),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field_compatible&nbsp;t&nbsp;path&nbsp;p&nbsp;-&gt;&nbsp;isptr&nbsp;p&nbsp;*)</span><br/>
</div>

<div class="doc">
So therefore, <span class="inlinecode"><span class="id" type="var">field_compatible_isptr</span></span> solves the goal. 
</div>
<div class="code code-tight">
<span class="id" type="tactic">eapply</span> <span class="id" type="lemma">field_compatible_isptr</span>; <span class="id" type="tactic">eauto</span>.<br/>
<span class="comment">(*&nbsp;Now&nbsp;you&nbsp;have&nbsp;some&nbsp;insight&nbsp;into&nbsp;how&nbsp;<span class="inlinecode"><span class="id" type="var">entailer</span>!</span>&nbsp;works.&nbsp;*)</span><br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
But when you define a new spatial predicate <span class="inlinecode"><span class="id" type="var">mpred</span></span> such as <span class="inlinecode"><span class="id" type="var">listrep</span></span>,
   the <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> tactic does not know how to deduce <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> facts
   from the <span class="inlinecode"><span class="id" type="var">listrep</span></span> conjunct: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="listrep_facts_example"><span class="id" type="lemma">listrep_facts_example</span></a>:<br/>
&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |-- !! (<span class="id" type="definition">isptr</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> ∨ <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>=<span class="id" type="definition">nullval</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Here, <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> threw away the left-hand-side and left an unprovable goal.
   Let's see why. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="listrep_facts_example"><span class="id" type="lemma">listrep_facts_example</span></a>:<br/>
&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |-- !! (<span class="id" type="definition">isptr</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> ∨ <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>=<span class="id" type="definition">nullval</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
First <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> would use <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> to see (from the Hint database)
   what can be deduced from <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
But <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> did not add anything above the line.  That's because
   there's no Hint in the Hint database for <span class="inlinecode"><span class="id" type="var">listrep</span></span>.  
   Therefore we must add one.   The conventional name for such a lemma
   is  <span class="inlinecode"><span class="id" type="var">f_local_facts</span></span>, if your new predicate is named <span class="inlinecode"><span class="id" type="var">f</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="listrep_local_facts"><span class="id" type="lemma">listrep_local_facts</span></a>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |--<br/>
&nbsp;&nbsp;&nbsp;!! (<span class="id" type="definition">is_pointer_or_null</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> ∧ (<a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>=<span class="id" type="definition">nullval</span> ↔ <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a>=<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil"><span class="id" type="constructor">nil</span></a>)).<br/>
</div>

<div class="doc">
For each spatial predicate <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">f</span>(<span class="id" type="var">_</span>):</span> <span class="inlinecode"><span class="id" type="var">mpred</span></span>,
  there should be <i>one</i> "local fact", a lemma of the form
  <span class="inlinecode"><span class="id" type="var">f</span>(<span class="id" type="var">_</span>)</span> <span class="inlinecode">|--</span> <span class="inlinecode">!!</span> <span class="inlinecode"><span class="id" type="var">_</span></span>.  On the right hand side, put all the propositions
  you can derive from <span class="inlinecode"><span class="id" type="var">f</span>(<span class="id" type="var">_</span>)</span>.  In this case, we know:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">p</span></span> is either a pointer or null (it's never <span class="inlinecode"><span class="id" type="var">Vundef</span></span>, or <span class="inlinecode"><span class="id" type="var">Vfloat</span></span>, or a nonzero <span class="inlinecode"><span class="id" type="var">Vint</span></span>).

</li>
<li> <span class="inlinecode"><span class="id" type="var">p</span></span> is null, if and only if <span class="inlinecode"><span class="id" type="var">sigma</span></span> is nil.

</li>
</ul>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
We will prove this entailment by induction on sigma 
</div>
<div class="code code-tight">
<span class="id" type="var">revert</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">p</span>.<br/>
- <span class="comment">(**&nbsp;In&nbsp;the&nbsp;base&nbsp;case,&nbsp;<span class="inlinecode"><span class="id" type="var">sigma</span></span>&nbsp;is&nbsp;nil.&nbsp;&nbsp;We&nbsp;can&nbsp;unfold&nbsp;the&nbsp;definition<br/>
&nbsp;&nbsp;&nbsp;of&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span>&nbsp;to&nbsp;see&nbsp;what&nbsp;that&nbsp;means.&nbsp;*)</span><br/>
&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>.<br/>
</div>

<div class="doc">
Now we have an entailment with a proposition <span class="inlinecode"><span class="id" type="var">p</span>=<span class="id" type="var">nullval</span></span> on the left.
 To move that proposition above the line, we could do <span class="inlinecode"><span class="id" type="var">Intros</span></span>, but
 it's easier just to call on <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> to see how it can simplify (and perhaps
 partially solve) this entailment goal: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
&nbsp;<span class="comment">(*&nbsp;The&nbsp;<span class="inlinecode"><span class="id" type="var">entailer</span>!</span>&nbsp;has&nbsp;left&nbsp;an&nbsp;ordinary&nbsp;proposition,&nbsp;which&nbsp;is&nbsp;easy&nbsp;to&nbsp;solve.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">auto</span>.<br/>
- <span class="comment">(**&nbsp;In&nbsp;the&nbsp;inductive&nbsp;case,&nbsp;we&nbsp;can&nbsp;again&nbsp;unfold&nbsp;the&nbsp;definition<br/>
&nbsp;&nbsp;&nbsp;of&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode">(<span class="id" type="var">a</span>::<span class="id" type="var">sigma</span>)</span>;&nbsp;but&nbsp;then&nbsp;it's&nbsp;good&nbsp;to&nbsp;fold&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span>.<br/>
&nbsp;&nbsp;&nbsp;Replace&nbsp;the&nbsp;semicolon&nbsp;<span class="inlinecode">;</span>&nbsp;with&nbsp;a&nbsp;period&nbsp;in&nbsp;the&nbsp;next&nbsp;line,&nbsp;to&nbsp;see&nbsp;why.&nbsp;*)</span><br/>
&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>; <span class="id" type="var">fold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>.<br/>
</div>

<div class="doc">
Warning!  Sometimes <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> is too aggressive.  If we use it here,
  it will throw away the left-hand side because it doesn't understand how to look inside an 
  EXistential quantitier.
  The exclamation point <span class="inlinecode">!</span> is a warning that <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> can turn a provable
  goal into an unprovable goal.  The less aggressive version is without
  the exclamation point:  <span class="inlinecode"><span class="id" type="var">entailer</span></span>.  
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="var">entailer</span>.<br/>
</div>

<div class="doc">
Notice that the existentially bound variable <span class="inlinecode"><span class="id" type="var">y</span></span> has been moved above the line. 
<div class="paragraph"> </div>

 In general, should you use <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> or <span class="inlinecode"><span class="id" type="var">entailer</span></span>  in ordinary proofs?  Usually <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> is best: it's 
  faster, and it does more work for you.  Only if you 
  find that <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> has gone into a dead end, should
  you use <span class="inlinecode"><span class="id" type="var">entailer</span></span> instead. 
<div class="paragraph"> </div>

 Now it is safe to use <span class="inlinecode"><span class="id" type="var">entailer</span>!</span>, because it understands both <span class="inlinecode"><span class="id" type="var">data_at</span></span> and <span class="inlinecode"><span class="id" type="var">listrep</span></span>. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Notice that entailer! has put several facts above the line:
  <span class="inlinecode"><span class="id" type="var">field_compatible</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">[]</span> <span class="inlinecode"><span class="id" type="var">p</span></span> and <span class="inlinecode"><span class="id" type="var">value_fits</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">a</span>,<span class="id" type="var">y</span>)</span> come from the 
  <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> hint database, from the <span class="inlinecode"><span class="id" type="var">data_at</span></span> conjunct;  and 
  <span class="inlinecode"><span class="id" type="var">is_pointer_or_null</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> and <span class="inlinecode"><span class="id" type="var">y</span>=<span class="id" type="var">nullval</span></span> <span class="inlinecode">↔</span> <span class="inlinecode"><span class="id" type="var">sigma</span>=[]</span> come from the
  the <span class="inlinecode"><span class="id" type="var">listrep</span></span> conjunct, using the induction hypothesis <span class="inlinecode"><span class="id" type="var">IHsigma</span></span>.

<div class="paragraph"> </div>

  Now, let's split the goal and take the two cases separately. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span>.<br/>
&nbsp;&nbsp;*<br/>
&nbsp;<span class="id" type="tactic">clear</span> - <span class="id" type="var">H</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
&nbsp;<span class="id" type="tactic">subst</span> <span class="id" type="var">p</span>.<br/>
</div>

<div class="doc">
It happens that <span class="inlinecode"><span class="id" type="var">field_compatible</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> implies <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="lemma">field_compatible_isptr</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;:&nbsp;forall&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(path&nbsp;:&nbsp;list&nbsp;gfield)&nbsp;(p&nbsp;:&nbsp;val),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field_compatible&nbsp;t&nbsp;path&nbsp;p&nbsp;-&gt;&nbsp;isptr&nbsp;p&nbsp;*)</span><br/>
</div>

<div class="doc">
 The predicate isptr excludes the null pointer, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="definition">isptr</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;fun&nbsp;v&nbsp;:&nbsp;val&nbsp;=&gt;&nbsp;match&nbsp;v&nbsp;with&nbsp;Vptr&nbsp;_&nbsp;_&nbsp;=&gt;&nbsp;True&nbsp;|&nbsp;_&nbsp;=&gt;&nbsp;False&nbsp;end&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <span class="id" type="definition">nullval</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;if&nbsp;Archi.ptr64&nbsp;then&nbsp;Vlong&nbsp;Int64.zero&nbsp;else&nbsp;Vint&nbsp;Int.zero&nbsp;*)</span><br/>
</div>

<div class="doc">
Therefore <span class="inlinecode"><span class="id" type="var">H</span></span> is a contradiction.  We can proceed with, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="lemma">field_compatible_nullval</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;forall&nbsp;(CS&nbsp;:&nbsp;compspecs)&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(f&nbsp;:&nbsp;list&nbsp;gfield)&nbsp;(P&nbsp;:&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field_compatible&nbsp;t&nbsp;f&nbsp;nullval&nbsp;-&gt;&nbsp;P&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <span class="id" type="lemma">field_compatible_nullval</span>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;* <span class="comment">(*The&nbsp;case&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">sigma</span>=[]</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">p</span>=<span class="id" type="var">nullval</span></span>&nbsp;is&nbsp;easy,&nbsp;by&nbsp;inversion:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now we add this lemma to the Hint database called <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Hint</span> <span class="id" type="keyword">Resolve</span> <span class="id" type="var">listrep_local_facts</span> : <span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
<a name="lab34"></a><h3 class="section">Valid pointers, and the <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> Hint database</h3>

<div class="paragraph"> </div>

 In the C language, you can do a pointer comparison such as <span class="inlinecode"><span class="id" type="var">p</span>!=<span class="id" type="var">NULL</span></span> or
    <span class="inlinecode"><span class="id" type="var">p</span>==<span class="id" type="var">q</span></span> only if <span class="inlinecode"><span class="id" type="var">p</span></span> is a <i>valid pointer</i>, that is, either NULL or actually 
    pointing within an allocated object.  One way to prove that <span class="inlinecode"><span class="id" type="var">p</span></span> is
    valid is if, for example,   <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span>, meaning that <span class="inlinecode"><span class="id" type="var">p</span></span>
    is pointing at a list cell.  There is a hint database <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> from
    which the predicate <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> can be proved automatically.
    For example: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="struct_list_valid_pointer_example"><span class="id" type="lemma">struct_list_valid_pointer_example</span></a>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">h</span> <span class="id" type="var">y</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="definition">data_at</span> <span class="id" type="definition">Tsh</span> <a class="idref" href="Verif_reverse.html#t_list"><span class="id" type="definition">t_list</span></a> (<a class="idref" href="Verif_reverse.html#h"><span class="id" type="variable">h</span></a>,<a class="idref" href="Verif_reverse.html#y"><span class="id" type="variable">y</span></a>) <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |-- <span class="id" type="definition">valid_pointer</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">valid_pointer</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
However, the hint database does not know about user-defined 
    separation-logic predicates (<span class="inlinecode"><span class="id" type="var">mpred</span></span>) such as <span class="inlinecode"><span class="id" type="var">listrep</span></span>; for example: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="listrep_valid_pointer_example"><span class="id" type="lemma">listrep_valid_pointer_example</span></a>:<br/>
&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span>, <br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |-- <span class="id" type="definition">valid_pointer</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">valid_pointer</span>.<br/>
</div>

<div class="doc">
Notice that <span class="inlinecode"><span class="id" type="tactic">auto</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span>...</span> did not solve the proof goal 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
Therefore, we should prove the appropriate lemma, and add it to the
   Hint database.  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="listrep_valid_pointer"><span class="id" type="lemma">listrep_valid_pointer</span></a>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a> |-- <span class="id" type="definition">valid_pointer</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
The main point is to unfold listrep. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>.<br/>
</div>

<div class="doc">
Now we can prove it by case analysis on sigma; we don't even need
   induction. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">simpl</span>.<br/>
* <span class="comment">(**&nbsp;The&nbsp;&nbsp;nil&nbsp;case&nbsp;is&nbsp;easy:&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">hint</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(**&nbsp;&nbsp;The&nbsp;cons&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(**&nbsp;To&nbsp;get&nbsp;past&nbsp;the&nbsp;EXistential,&nbsp;use&nbsp;either&nbsp;<span class="inlinecode"><span class="id" type="var">Intros</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span>&nbsp;or,&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Now this solves using the Hint database <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span>, because the
     <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">v</span>,<span class="id" type="var">y</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span> on the left is enough to prove the goal. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">valid_pointer</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now we add this lemma to the Hint database 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Hint</span> <span class="id" type="keyword">Resolve</span> <span class="id" type="var">listrep_valid_pointer</span> : <span class="id" type="var">valid_pointer</span>.<br/>
</div>

<div class="doc">
<a name="lab35"></a><h2 class="section">Specification of the <span class="inlinecode"><span class="id" type="var">reverse</span></span> function.</h2>
 A <span class="inlinecode"><span class="id" type="var">funspec</span></span> characterizes the precondition required for calling the function
  and the postcondition guaranteed by the function.
 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="reverse_spec"><span class="id" type="definition">reverse_spec</span></a> : <span class="id" type="definition">ident</span> * <span class="id" type="inductive">funspec</span> :=<br/>
&nbsp;<span class="id" type="notation">DECLARE</span> <span class="id" type="definition">_reverse</span><br/>
&nbsp;&nbsp;<span class="id" type="notation">WITH</span> <span class="id" type="var">sigma</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">val</span>, <span class="id" type="var">p</span>: <span class="id" type="inductive">val</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span>  [ <span class="id" type="definition">_p</span> <span class="id" type="var">OF</span> (<span class="id" type="definition">tptr</span> <a class="idref" href="Verif_reverse.html#t_list"><span class="id" type="definition">t_list</span></a>) ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">PROP</span> ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">LOCAL</span> (<span class="id" type="constructor">temp</span> <span class="id" type="definition">_p</span> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">SEP</span> (<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a> <a class="idref" href="Verif_reverse.html#p"><span class="id" type="variable">p</span></a>)<br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ (<span class="id" type="definition">tptr</span> <a class="idref" href="Verif_reverse.html#t_list"><span class="id" type="definition">t_list</span></a>) ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">EX</span> <span class="id" type="var">q</span>:<span class="id" type="inductive">val</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">PROP</span> () <span class="id" type="notation">LOCAL</span> (<span class="id" type="constructor">temp</span> <span class="id" type="definition">ret_temp</span> <a class="idref" href="Verif_reverse.html#q"><span class="id" type="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">SEP</span> (<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>(<a class="idref" href="http://coq.inria.fr/library/Coq.Lists.List.html#rev"><span class="id" type="definition">rev</span></a> <a class="idref" href="Verif_reverse.html#sigma"><span class="id" type="variable">sigma</span></a>) <a class="idref" href="Verif_reverse.html#q"><span class="id" type="variable">q</span></a>).<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> The WITH clause says, there is a value <span class="inlinecode"><span class="id" type="var">sigma</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">val</span></span> and a value <span class="inlinecode"><span class="id" type="var">p</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span>, 
              visible in both the precondition and the postcondition.

</li>
<li> The PREcondition says, 
<ul class="doclist">
<li> There is a single function-parameter named <span class="inlinecode"><span class="id" type="var">_p</span></span>, whose C type is "pointer to struct list"

</li>
<li> LOCAL:  The C local variable <span class="inlinecode"><span class="id" type="var">_p</span></span> contains the Coq value <span class="inlinecode"><span class="id" type="var">p</span></span>;

</li>
<li> SEP: in memory at address <span class="inlinecode"><span class="id" type="var">p</span></span> there is a linked list representing <span class="inlinecode"><span class="id" type="var">sigma</span></span>.

</li>
</ul>

</li>
<li> The POSTcondition says, 
<ul class="doclist">
<li> the function returns a value whose C type is "pointer to struct list"; and

</li>
<li> there exists a value <span class="inlinecode"><span class="id" type="var">q</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span>, such that

</li>
<li> LOCAL: the "return temporary", a pseudovariable holdingthe 
           function's return value, holds the value <span class="inlinecode"><span class="id" type="var">q</span></span>

</li>
<li> SEP: in memory at address <span class="inlinecode"><span class="id" type="var">q</span></span> there is a linked list representing <span class="inlinecode"><span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span>.

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

 The global function spec, characterizing the
  preconditions/postconditions of all the functions
  that your proved-correct program will call. 
  Normally you include all the functions here, but
  in this tutorial example we include only one. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="Gprog"><span class="id" type="definition">Gprog</span></a> : <span class="id" type="definition">funspecs</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ltac</span>:(<span class="id" type="var">with_library</span> <span class="id" type="definition">prog</span> [ <a class="idref" href="Verif_reverse.html#reverse_spec"><span class="id" type="definition">reverse_spec</span></a> ]).<br/>
</div>

<div class="doc">
<a name="lab36"></a><h2 class="section">Proof of the <span class="inlinecode"><span class="id" type="var">reverse</span></span> function</h2>

<div class="paragraph"> </div>

 For each function definition in the C program, prove that the
 function-body (in this case, f_reverse) satisfies its specification
  (in this case, reverse_spec).  
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="body_reverse"><span class="id" type="lemma">body_reverse</span></a>: <span class="id" type="definition">semax_body</span> <a class="idref" href="Verif_reverse.html#Vprog"><span class="id" type="definition">Vprog</span></a> <a class="idref" href="Verif_reverse.html#Gprog"><span class="id" type="definition">Gprog</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">f_reverse</span> <a class="idref" href="Verif_reverse.html#reverse_spec"><span class="id" type="definition">reverse_spec</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
</div>

<div class="doc">
The start_function tactic "opens up" a semax_body
    proof goal into a Hoare triple. 
</div>
<div class="code code-tight">
<span class="id" type="var">start_function</span>.<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">semax</span></span> judgment has four parts:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">Delta</span></span>, a "type context" (<span class="inlinecode"><span class="id" type="var">tycontext</span></span>) that contains information
    about the (C language) types of C variables, specifications (<span class="inlinecode"><span class="id" type="var">funspec</span></span>s)
    of global functions, and so on.

</li>
<li> Precondition, in this example <span class="inlinecode">(<span class="id" type="var">PROP</span></span> <span class="inlinecode">(</span> <span class="inlinecode">)</span>  <span class="inlinecode"><span class="id" type="var">LOCAL</span></span> <span class="inlinecode">(<span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_p</span></span> <span class="inlinecode"><span class="id" type="var">p</span>)</span>  <span class="inlinecode"><span class="id" type="var">SEP</span></span> <span class="inlinecode">(<span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span> <span class="inlinecode"><span class="id" type="var">p</span>))</span>

</li>
<li> Command, in this example <span class="inlinecode"></span> <span class="inlinecode">(<span class="id" type="var">_w</span></span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" type="var">tptr</span></span> <span class="inlinecode"><span class="id" type="var">tvoid</span>)</span> <span class="inlinecode">(0);</span> <span class="inlinecode"><span class="id" type="var">MORE_COMMANDS</span>)</span>

</li>
<li> Postcondition, in this example <span class="inlinecode"><span class="id" type="var">POSTCONDITION</span></span>

</li>
</ul>

<div class="paragraph"> </div>

 Notice that the precondition matches exactly the PRE clause of the
 <span class="inlinecode"><span class="id" type="var">reverse_spec</span></span>.  The postcondition matches too, but it's hidden inside
 an abbreviation.  You can see the entire command and postcondition
 by writing, 
</div>
<div class="code code-tight">
<span class="id" type="tactic">subst</span> <span class="id" type="var">POSTCONDITION</span> <span class="id" type="var">MORE_COMMANDS</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="definition">abbreviate</span>.<br/>
</div>

<div class="doc">
The command is what you would expect by reading the original C program.

<div class="paragraph"> </div>

  The postcondition contains within it, the funspec's postcondition.

<div class="paragraph"> </div>

  Normally we hide the command and postcondition inside these 
  abbreviations <span class="inlinecode"><span class="id" type="var">POSTCONDITION</span>,</span> <span class="inlinecode"><span class="id" type="var">MORE_COMMANDS</span></span> because, in a proof
  by forward symbolic execution, at any point we are immediately concerned
  with just the precondition and the first command. 
  So therefore, let's put back the abbreviations 
</div>
<div class="code code-tight">
<span class="id" type="var">abbreviate_semax</span>.<br/>
</div>

<div class="doc">
The first statement (command) in the function-body is the assignment
     statement  <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span>;</span>, where <span class="inlinecode"><span class="id" type="var">NULL</span></span> is a C <span class="inlinecode">#<span class="id" type="var">define</span></span> that exands to
     "cast 0 to void-pointer", <span class="inlinecode">(<span class="id" type="var">void</span></span> <span class="inlinecode">*</span> <span class="inlinecode">)0</span>, here ugly-printed as <span class="inlinecode">(<span class="id" type="var">tptr</span></span> <span class="inlinecode"><span class="id" type="var">tvoid</span>)(0)</span>.
    To apply the separation-logic assignment rule to this command, simply
     use the tactic <span class="inlinecode"><span class="id" type="var">forward</span></span> : 
</div>
<div class="code code-tight">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;w&nbsp;=&nbsp;NULL;&nbsp;*)</span><br/>
</div>

<div class="doc">
The new <span class="inlinecode"><span class="id" type="var">semax</span></span> judgment is for the rest of the function body <i>after</i>
     the command <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span></span>.  The precondition of this <span class="inlinecode"><span class="id" type="var">semax</span></span> is actually
     the postcondition of the <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span></span> statement.  It's much like the
     precondition of <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span></span>, but contains the additional LOCAL fact,
     <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_w</span></span> <span class="inlinecode">(<span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">Int.repr</span></span> <span class="inlinecode">0))</span>, that is, the local variable <span class="inlinecode"><span class="id" type="var">_w</span></span> contains <span class="inlinecode"><span class="id" type="var">nullval</span></span>. 
<div class="paragraph"> </div>

 We can view the Hoare-logic proof of this program as a "symbolic execution",
     where the symbolic states are assertions.  We can symbolically execute
     the next command by saying <span class="inlinecode"><span class="id" type="var">forward</span></span> again. 
</div>
<div class="code code-tight">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;v&nbsp;=&nbsp;p;&nbsp;*)</span><br/>
</div>

<div class="doc">
Examine the precondition, and notice that now we have the additional
    fact, <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_v</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>. 
<div class="paragraph"> </div>

 We cannot the next step using <span class="inlinecode"><span class="id" type="var">forward</span></span> ... 
</div>
<div class="code code-tight">
<span class="id" type="var">Fail</span> <span class="id" type="var">forward</span>.<br/>
</div>

<div class="doc">
... because the next command is a <span class="inlinecode"><span class="id" type="var">while</span></span> loop.
  To prove a while-loop, you must supply a loop invariant,
    in this case (EX s<sub>1</sub>  PROP(...)LOCAL(...)(SEP(...)).  
</div>
<div class="code code-tight">
<span class="id" type="var">forward_while</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="notation">EX</span> <span class="id" type="var">s<sub>1</sub></span>: <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">val</span>, <span class="id" type="notation">EX</span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">val</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">EX</span> <span class="id" type="var">w</span>: <span class="id" type="inductive">val</span>, <span class="id" type="notation">EX</span> <span class="id" type="var">v</span>: <span class="id" type="inductive">val</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">PROP</span> (<span class="id" type="var">sigma</span> = <a class="idref" href="http://coq.inria.fr/library/Coq.Lists.List.html#rev"><span class="id" type="definition">rev</span></a> <a class="idref" href="Verif_reverse.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="Verif_reverse.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">LOCAL</span> (<span class="id" type="constructor">temp</span> <span class="id" type="definition">_w</span> <a class="idref" href="Verif_reverse.html#w"><span class="id" type="variable">w</span></a>; <span class="id" type="constructor">temp</span> <span class="id" type="definition">_v</span> <a class="idref" href="Verif_reverse.html#v"><span class="id" type="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">SEP</span> (<a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> <a class="idref" href="Verif_reverse.html#w"><span class="id" type="variable">w</span></a>; <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <a class="idref" href="Verif_reverse.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> <a class="idref" href="Verif_reverse.html#v"><span class="id" type="variable">v</span></a>)).<br/>
</div>

<div class="doc">
The forward_while tactic leaves four subgoals,
    which we mark with * (the Coq "bullet") 
</div>
<div class="code code-tight">
* <span class="comment">(*&nbsp;Prove&nbsp;that&nbsp;(current)&nbsp;precondition&nbsp;implies&nbsp;the&nbsp;loop&nbsp;invariant&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;On&nbsp;the&nbsp;left-hand&nbsp;side&nbsp;of&nbsp;this&nbsp;entailment&nbsp;is&nbsp;the&nbsp;precondition<br/>
&nbsp;&nbsp;(that&nbsp;we&nbsp;had&nbsp;already&nbsp;established&nbsp;by&nbsp;forward&nbsp;symbolic&nbsp;execution&nbsp;to&nbsp;this<br/>
&nbsp;&nbsp;point)&nbsp;for&nbsp;the&nbsp;entire&nbsp;while-loop.&nbsp;&nbsp;On&nbsp;the&nbsp;right-hand&nbsp;side&nbsp;is&nbsp;the&nbsp;loop<br/>
&nbsp;&nbsp;invariant,&nbsp;that&nbsp;we&nbsp;just&nbsp;gave&nbsp;to&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">forward_while</span></span>&nbsp;tactic.&nbsp;&nbsp;Because<br/>
&nbsp;&nbsp;the&nbsp;right_hand&nbsp;side&nbsp;has&nbsp;for&nbsp;existentials,&nbsp;a&nbsp;good&nbsp;proof&nbsp;strategy&nbsp;is&nbsp;to<br/>
&nbsp;&nbsp;choose&nbsp;values&nbsp;for&nbsp;them,&nbsp;using&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">Exists</span></span>&nbsp;tactic.&nbsp;*)</span><br/>
<span class="id" type="var">Exists</span> (@<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="inductive">val</span>) <span class="id" type="var">sigma</span> <span class="id" type="definition">nullval</span> <span class="id" type="var">p</span>.<br/>
</div>

<div class="doc">
Now we have a quantifier-free proof goal; let us see whether <span class="inlinecode"><span class="id" type="var">entailer</span>!</span>
    can solve some parts of it. 
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Indeed, the <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> did a fine job.  What's left is a property of our
    user-defined <span class="inlinecode"><span class="id" type="var">listrep</span></span> predicate:  <span class="inlinecode"><span class="id" type="var">emp</span></span> <span class="inlinecode">|--</span> <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode">[]</span> <span class="inlinecode"><span class="id" type="var">nullval</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>.<br/>
</div>

<div class="doc">
Now that the user-defined predicate is unfolded, <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> can solve
     the residual entailment. 
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(*&nbsp;Prove&nbsp;that&nbsp;loop&nbsp;invariant&nbsp;implies&nbsp;typechecking&nbsp;of&nbsp;loop&nbsp;condition&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;The&nbsp;second&nbsp;subgoal&nbsp;of&nbsp;<span class="inlinecode"><span class="id" type="var">forward_while</span></span>&nbsp;is&nbsp;to&nbsp;prove&nbsp;that&nbsp;the&nbsp;loop-test<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;condition&nbsp;can&nbsp;execute&nbsp;without&nbsp;crashing.&nbsp;&nbsp;&nbsp;Consider,&nbsp;for&nbsp;example,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;C-language&nbsp;while&nbsp;loop,&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">while</span></span> <span class="inlinecode">(<span class="id" type="var">a</span>[<span class="id" type="var">i</span>]&gt;0)</span> <span class="inlinecode">...</span>,&nbsp;where&nbsp;the&nbsp;value&nbsp;of&nbsp;<span class="inlinecode"><span class="id" type="var">i</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;might&nbsp;exceed&nbsp;the&nbsp;bounds&nbsp;of&nbsp;the&nbsp;array.&nbsp;&nbsp;Then&nbsp;this&nbsp;would&nbsp;be&nbsp;a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"buffer&nbsp;overrun",&nbsp;and&nbsp;is&nbsp;"undefined&nbsp;behavior"&nbsp;("stuck")&nbsp;in&nbsp;the&nbsp;C&nbsp;semantics.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We&nbsp;must&nbsp;prove&nbsp;that,&nbsp;given&nbsp;the&nbsp;current&nbsp;precondition&nbsp;(in&nbsp;this&nbsp;case,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;loop&nbsp;invariant),&nbsp;the&nbsp;loop&nbsp;test&nbsp;is&nbsp;not&nbsp;"undefined&nbsp;behavior."&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;proof&nbsp;goal&nbsp;takes&nbsp;the&nbsp;form,&nbsp;<span class="inlinecode"><span class="id" type="var">current</span>-<span class="id" type="var">precondition</span></span> <span class="inlinecode">|--</span> <span class="inlinecode"><span class="id" type="var">tc_expr</span></span> <span class="inlinecode"><span class="id" type="var">Delta</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;<span class="inlinecode"><span class="id" type="var">e</span></span>&nbsp;is&nbsp;the&nbsp;loop-test&nbsp;expression.&nbsp;&nbsp;You&nbsp;can&nbsp;pronounce&nbsp;<span class="inlinecode"><span class="id" type="var">tc_expr</span></span>&nbsp;as<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type-check&nbsp;expression",&nbsp;since&nbsp;the&nbsp;Verifiable&nbsp;C&nbsp;type-checker&nbsp;ensures<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;such&nbsp;expressions&nbsp;are&nbsp;safe&nbsp;(sometimes&nbsp;with&nbsp;a&nbsp;subgoal&nbsp;for&nbsp;you&nbsp;to&nbsp;prove).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fortunately,&nbsp;in&nbsp;most&nbsp;cases&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">entailer</span>!</span>&nbsp;solves&nbsp;<span class="inlinecode"><span class="id" type="var">tc_expr</span></span>&nbsp;goals&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completely&nbsp;automatically:&nbsp;&nbsp;*)</span><br/>
<span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(*&nbsp;Prove&nbsp;that&nbsp;loop&nbsp;body&nbsp;preserves&nbsp;invariant&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;As&nbsp;usual&nbsp;in&nbsp;any&nbsp;Hoare&nbsp;logic&nbsp;(including&nbsp;Separation&nbsp;Logic),&nbsp;we&nbsp;need&nbsp;to&nbsp;prove<br/>
&nbsp;&nbsp;&nbsp;that&nbsp;the&nbsp;loop&nbsp;body&nbsp;preserves&nbsp;the&nbsp;loop&nbsp;invariant,&nbsp;more&nbsp;precisely,<br/>
&nbsp;&nbsp;&nbsp;-&nbsp;{Inv&nbsp;/\&nbsp;Test}&nbsp;body&nbsp;{Inv}<br/>
&nbsp;&nbsp;&nbsp;where&nbsp;Test&nbsp;is&nbsp;the&nbsp;loop-test&nbsp;condition.&nbsp;&nbsp;Here,&nbsp;the&nbsp;loop-test&nbsp;condition<br/>
&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;original&nbsp;C&nbsp;code&nbsp;is&nbsp;<span class="inlinecode">(<span class="id" type="var">v</span>)</span>,&nbsp;and&nbsp;its&nbsp;manifestation&nbsp;above&nbsp;the&nbsp;line&nbsp;is<br/>
&nbsp;&nbsp;&nbsp;the&nbsp;hypothesis&nbsp;<span class="inlinecode"><span class="id" type="var">HRE</span>:</span> <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">v</span></span>,&nbsp;meaning&nbsp;that&nbsp;<span class="inlinecode"><span class="id" type="var">v</span></span>&nbsp;is&nbsp;a&nbsp;(non-null)&nbsp;pointer.<br/>
<br/>
&nbsp;&nbsp;&nbsp;The&nbsp;loop&nbsp;invariant&nbsp;was&nbsp;<span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>:_,</span> <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>:_,</span> <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">w</span>:_,</span> <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">v</span>:_,</span> <span class="inlinecode">...</span>,&nbsp;and&nbsp;here<br/>
&nbsp;&nbsp;&nbsp;all&nbsp;the&nbsp;existentially&nbsp;quantified&nbsp;variables&nbsp;on&nbsp;the&nbsp;left&nbsp;side&nbsp;of&nbsp;the&nbsp;entailment<br/>
&nbsp;&nbsp;&nbsp;have&nbsp;been&nbsp;moved&nbsp;above&nbsp;the&nbsp;line:&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span>&nbsp;and&nbsp;<span class="inlinecode"><span class="id" type="var">w</span>,<span class="id" type="var">v</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;The&nbsp;PROP&nbsp;part&nbsp;of&nbsp;the&nbsp;loop&nbsp;invariant&nbsp;was&nbsp;<span class="inlinecode"><span class="id" type="var">sigma</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span>,&nbsp;and&nbsp;<br/>
&nbsp;&nbsp;&nbsp;it&nbsp;has&nbsp;also&nbsp;been&nbsp;moved&nbsp;above&nbsp;the&nbsp;line,&nbsp;as&nbsp;hypothesis&nbsp;<span class="inlinecode"><span class="id" type="var">H</span></span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;So&nbsp;now&nbsp;we&nbsp;would&nbsp;like&nbsp;to&nbsp;do&nbsp;forward-symbolic&nbsp;execution&nbsp;through<br/>
&nbsp;&nbsp;&nbsp;the&nbsp;four&nbsp;assignment&nbsp;statements&nbsp;in&nbsp;the&nbsp;loop&nbsp;body.&nbsp;*)</span><br/>
<span class="id" type="var">Fail</span> <span class="id" type="var">forward</span>.<br/>
</div>

<div class="doc">
But we cannot go forward through <span class="inlinecode"><span class="id" type="var">t</span>=<span class="id" type="var">v</span>→<span class="id" type="var">tail</span>;</span> because that would
   require a SEP conjunct in the precondition of the form 
   <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">sh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">_</span>,_)</span> <span class="inlinecode"><span class="id" type="var">v</span></span>, and there is no such conjunct.  Actually,
   there is such a conjunct, but it is hiding inside <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> <span class="inlinecode"><span class="id" type="var">v</span></span>.
   That is, there is such a conjunct as long as <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> is not <span class="inlinecode"><span class="id" type="var">nil</span></span>.
   Let's do case analysis on s<sub>2</sub>: 
</div>
<div class="code code-tight">
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">h</span> <span class="id" type="var">r</span>].<br/>
&nbsp;- <span class="comment">(*&nbsp;s<sub>2</sub>=nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(**&nbsp;Suppose&nbsp;<span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>=<span class="id" type="var">nil</span></span>.&nbsp;&nbsp;If&nbsp;we&nbsp;unfold&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span>&nbsp;.&nbsp;.&nbsp;.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <span class="id" type="tactic">at</span> 2.<br/>
</div>

<div class="doc">
then we learn that <span class="inlinecode"><span class="id" type="var">v</span>=<span class="id" type="var">nullval</span></span>.  To move this fact (or any proposition)
    from the precondition to above-the-line, we use <span class="inlinecode"><span class="id" type="var">Intros</span></span>: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Intros</span>.<br/>
</div>

<div class="doc">
Now, above the line, we have <span class="inlinecode"><span class="id" type="var">v</span>=<span class="id" type="var">nullval</span></span> and <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">v</span></span>; this is a contradiction. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">subst</span>. <span class="id" type="var">contradiction</span>.<br/>
&nbsp;- <span class="comment">(*&nbsp;s<sub>2</sub>=h::r&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(**&nbsp;Suppose&nbsp;<span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>=<span class="id" type="var">h</span>::<span class="id" type="var">r</span></span>.&nbsp;&nbsp;We&nbsp;can&nbsp;unfold/fold&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span>&nbsp;conjunct&nbsp;for&nbsp;<span class="inlinecode"><span class="id" type="var">h</span>::<span class="id" type="var">r</span></span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;you&nbsp;don't&nbsp;remember&nbsp;why&nbsp;we&nbsp;do&nbsp;<span class="inlinecode"><span class="id" type="tactic">unfold</span>/<span class="id" type="var">fold</span></span>,&nbsp;then&nbsp;replace&nbsp;the&nbsp;semicolon<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(between&nbsp;the&nbsp;fold&nbsp;and&nbsp;the&nbsp;unfold)&nbsp;with&nbsp;a&nbsp;period&nbsp;and&nbsp;see&nbsp;what&nbsp;happens.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <span class="id" type="tactic">at</span> 2; <span class="id" type="var">fold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>.<br/>
</div>

<div class="doc">
By the definition of <span class="inlinecode"><span class="id" type="var">listrep</span></span>, at address <span class="inlinecode"><span class="id" type="var">v</span></span> there must exist a value <span class="inlinecode"><span class="id" type="var">y</span></span>
     and a list cell containing (h,y).  So let us move <span class="inlinecode"><span class="id" type="var">y</span></span> above the line: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Intros</span> <span class="id" type="var">y</span>.<br/>
</div>

<div class="doc">
Now we have the appropriate SEP conjuncts to be able to go <span class="inlinecode"><span class="id" type="var">forward</span></span>
   through the loop body 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;t&nbsp;=&nbsp;v-&gt;tail&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;v-&gt;tail&nbsp;=&nbsp;w;&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;w&nbsp;=&nbsp;v;&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;v&nbsp;=&nbsp;t;&nbsp;*)</span><br/>
</div>

<div class="doc">
At end of loop body; we must reestablish the loop invariant.
   The left-hand-side of this entailment is the current assertion (after
   the loop body); the right-hand side is simply our loop invariant.
   (Unfortunately, the <span class="inlinecode"><span class="id" type="var">forward_while</span></span> tactic has "uncurried" the existentials
   into a single EX that binds a 4-tuple.)
   Since the proof goal is a complicated-looking entailment, let's see
   if <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> can simplify it a bit: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Now, we can provide new values for <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">s<sub>2</sub></span>,<span class="id" type="var">w</span>,<span class="id" type="var">v</span></span> to instantiate the 
   four existentials; these are, respectively, <span class="inlinecode"><span class="id" type="var">h</span>::<span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">r</span>,<span class="id" type="var">v</span>,<span class="id" type="var">y</span></span>. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Exists</span> (<span class="id" type="var">h</span>::<span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">r</span>,<span class="id" type="var">v</span>,<span class="id" type="var">y</span>).<br/>
</div>

<div class="doc">
Again, we have a complicated-looking entailment; we ask <span class="inlinecode"><span class="id" type="var">entailer</span>!</span>
   to reduce it some more. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Lists.List.html#app_ass"><span class="id" type="abbreviation">app_ass</span></a>. <span class="id" type="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <span class="id" type="tactic">at</span> 3; <span class="id" type="var">fold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Exists</span> <span class="id" type="var">w</span>. <span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(*&nbsp;after&nbsp;the&nbsp;loop&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;As&nbsp;usual&nbsp;in&nbsp;any&nbsp;Hoare&nbsp;logic&nbsp;(including&nbsp;Separation&nbsp;Logic),&nbsp;the&nbsp;postcondition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;a&nbsp;while-loop&nbsp;is&nbsp;{Inv&nbsp;/\&nbsp;not&nbsp;Test},&nbsp;where&nbsp;Inv&nbsp;is&nbsp;the&nbsp;loop&nbsp;invariant<br/>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;Test&nbsp;is&nbsp;the&nbsp;loop&nbsp;test.&nbsp;&nbsp;Here,&nbsp;all&nbsp;the&nbsp;EXistentials&nbsp;and&nbsp;PROPs&nbsp;of&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;invariant&nbsp;have&nbsp;been&nbsp;moved&nbsp;above&nbsp;the&nbsp;line&nbsp;as&nbsp;<span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">s<sub>2</sub></span>,<span class="id" type="var">w</span>,<span class="id" type="var">v</span>,<span class="id" type="var">HRE</span>,<span class="id" type="var">H</span></span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;We&nbsp;can&nbsp;always&nbsp;go&nbsp;<span class="inlinecode"><span class="id" type="var">forward</span></span>&nbsp;through&nbsp;a&nbsp;<span class="inlinecode"><span class="id" type="keyword">return</span></span>&nbsp;statement:&nbsp;*)</span><br/>
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;return&nbsp;w;&nbsp;*)</span><br/>
</div>

<div class="doc">
Now we must prove that the current assertion (after the while-loop)
  entails the function postcondition.  The left-hand side of this entailment
  is what we had just before <span class="inlinecode"><span class="id" type="var">forward</span></span> through the <span class="inlinecode"><span class="id" type="keyword">return</span></span>;
  the right-hand side is the postcondition of <span class="inlinecode"><span class="id" type="var">reverse_spec</span></span>,
  after the local variables (etc.) have been simplified away.  We must
  demonstrate a pointer <span class="inlinecode"><span class="id" type="var">q</span></span> (here it's called <span class="inlinecode"><span class="id" type="var">x</span></span>) that satisfies the various
  conditions.  Here it's easy to find <span class="inlinecode"><span class="id" type="var">x</span></span>, since it's constrained to be
  equal to <span class="inlinecode"><span class="id" type="var">w</span></span>: 
</div>
<div class="code code-tight">
<span class="id" type="var">Exists</span> <span class="id" type="var">w</span>; <span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="tactic">rewrite</span> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#proj1"><span class="id" type="lemma">proj1</span></a> <span class="id" type="var">H<sub>1</sub></span>) <span class="id" type="tactic">by</span> <span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="tactic">unfold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a> <span class="id" type="tactic">at</span> 2; <span class="id" type="var">fold</span> <a class="idref" href="Verif_reverse.html#listrep"><span class="id" type="definition">listrep</span></a>.<br/>
<span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/library/Coq.Lists.List.html#app_nil_end"><span class="id" type="lemma">app_nil_end</span></a>, <a class="idref" href="http://coq.inria.fr/library/Coq.Lists.List.html#rev_involutive"><span class="id" type="lemma">rev_involutive</span></a>.<br/>
<span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>



</div>

</body>
</html>